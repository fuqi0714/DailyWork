# 二进制
## IEEE 754
### 浮点数格式

| 类型 | 数符位数 | 阶码位数 | 尾数数值位数 |总位数 |偏置值 |
| :-----| :----: | :----: |:----: |:----: |:----: |
| 单精度float| 1| 8|23|32|127 |
| 双精度double| 1 | 11|52|64 |1023|

[不同类型的表示范围](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
### 阶码有效范围
以8位为例,1(00000001) $\leq$ 阶码有效值 $\leq$ 254(11111110)
- 阶码有效值为0(00000000)代表非规格化数，阶码有效值255(11111111)代表无穷大

### 编码格式

| 符号位 | 阶码 | 尾数 | 表示 | 
| :-----| :----: | :----: |:----: |
| 0/1| 255| M $\neq$ 0|NaN|
| 0/1| 255| 0|+ $\infty$ , - $\infty$|
| 0/1| 1~254| M(正常规格化的情况)|(−1)<sup>S</sup>* (1.M) ×2<sup>(E−127)</sup>|
| 0/1| 0| M $\neq$ 0(无法规格化的情况)|(−1)<sup>S</sup>* (0.M) ×2<sup>(−126)</sup>|
| 0/1| 0| 0|+0，-0|



## 运算

### 原码一位乘法
计算规则
- 数值位取绝对值计算，最终结果的符号通过取两数符号进行异或运算决定
- 从乘数最低位开始，若最低位为1，部分积加上被乘数的绝对值后右移一位；若为0，则加上0后右移一位
    - 重复此操作，次数等于乘数的位数

|  乘数最低位(由于参与移位，每次相加操作后最低位发生变化)| 操作 |
| :-----| :----: |
| 0 | 部分积仅右移一位 |
| 1 | 部分积加上 $\vert X \vert $,之后右移一位 |

例：X=-13, Y=11, 数值位4位，符号位1位。计算X*Y 

$\vert X \vert $=1101 ， $\vert Y \vert $=1011

| 操作 |  部分积的高位| 部分积的低位/乘数| 舍弃部分 | 根据乘数最低位的值按照计算规则进行操作|
| :-----| :-----| ----: | :---- |:---- |
| 初始状态，进行比较| 00,0000| 101<font color="#dd0000">1</font> | <font color="#dd0000"></font> |按照计算规则对比乘数最低位的值。此时部分积加上 $\vert X \vert $,之后右移一位 |
| 加上 $\vert X \vert $| 00,1101| | <font color="#dd0000"></font> ||
| 结果| 00,1101| 101<font color="#dd0000">1</font> | <font color="#dd0000"></font> ||
| |  |  |  |相加操作结束 |
| 右移| 00,0110| 110<font color="#dd0000">1 </font>| 1  | 移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 00,0110| 110<font color="#dd0000">1 </font>| 1  |部分积加上 $\vert X \vert $,之后右移一位 |
| 加上 $\vert X \vert $| 00,1101|  |  ||
| 结果| 01,0011| 110<font color="#dd0000">1</font> | 1 ||
| |  |  |  |相加操作结束 |
| 右移| 00,1001| 111<font color="#dd0000">0 </font>| 11  | 移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 00,1001| 111<font color="#dd0000">0 </font>| 11  |仅右移一位 |
| 加上0| 00,0000| |   | |
| 结果| 00,1001| 111<font color="#dd0000">0 </font>| 11  | |
| |  |  |  |相加操作结束 |
| 右移| 00,0100| 101<font color="#dd0000">1 </font>| 011  | 移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 00,0100| 111<font color="#dd0000">1 </font>| 011  |仅右移一位 |
| 加上 $\vert X \vert $| 00,1101|  |  ||
| 结果| 01,0001| 111<font color="#dd0000">1 </font>| 011  | |
| 右移| 00,1000| 111<font color="#dd0000">1 </font>| 1011  |移位作用于整个积(高位积和低位积) |
| 得出结果| <u>00,1000</u>| <u>111<font color="#dd0000">1 </font></u>| 1011  |下划线部分为二进制原码绝对值 |

X、Y的符号进行异或运算：0 $\bigoplus$ 1=1
### 补码一位乘法
计算规则
- 符号位与数值位共同参与运算，被乘数取双符号位，乘数取单符号位
- 乘数末尾后增加一个辅助判断位，初值为0
- 对比乘数原末尾和辅助判断位的值，按照下表操作
    - 移位产生的补位需要符合补码性质
    - 重复移位-相加的操作直到乘数的符号位出于最末尾，此时根据下表内容做最后一次加法。将结果拼接得出最后的补码结果

|  乘数最低位(由于参与移位，每次相加操作后最低位发生变化)| 辅助位 | 操作 |
| :-----| :----: | :----: |
| 0 | 0 | 部分积仅右移一位 |
| 0 | 1 | 部分积加上[X]<sub>补</sub>,之后右移一位 |
| 1 | 0 | 部分积加上[-X]<sub>补</sub>,之后右移一位 |
| 1 | 1 | 部分积仅右移一位 |

例：X=-27, Y=13, 数值位5位，符号位1位，被乘数使用双符号位，乘数使用单符号位。计算X * Y

[X]<sub>原</sub>=11,11011, [X]<sub>补</sub>=11,00101, [-X]<sub>补</sub>=00,11011, [Y]<sub>原</sub>=[Y]<sub>补</sub>=00,01101
| 操作|  部分积的高位| 部分积的低位/乘数| 辅助位 | 根据辅助位红色字符与乘数位红色字符的组合，按照计算规则操作 |
| :-----| :-----| ----: | :---- |:----|
| 初始状态，进行比较| 00,00000| 0,0110<font color="#dd0000">1</font> | <font color="#dd0000">0</font> |辅助位初始上0，按照计算规则对比两位的组合。此时部分积先加上[-X]<sub>补</sub>,之后右移一位 |
| 加上[-X]<sub>补</sub>| 00,11011|  |  ||
| 结果| 00,11011|  |  | |
| |  |  |  |相加操作结束 |
| 右移| 00,01101| 10,0110 |  | 移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 00,01101| 10,011<font color="#dd0000">0</font> | <font color="#dd0000">1</font>0 |部分积加上[X]<sub>补</sub>,之后右移一位 |
| 加上[X]<sub>补</sub>| 11,00101|  |   |
| 结果| 11,10010|  |   |
| |  |  |  |相加操作结束 |
| 右移| 11,11001| 10,0110 |  | 移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 11,11001| 010,01<font color="#dd0000">1</font> | <font color="#dd0000">0</font>10 |部分积加上[-X]<sub>补</sub>,之后右移一位 |
| 加上[-X]<sub>补</sub>| 00,11011|  |   |
| 结果| 00,10100|  |   |
| |  |  |  |相加操作结束 |
| 右移| 00,01010| 0010,01 |  |移位作用于整个积(高位积和低位积) |
| |  |  |  |右移一位操作结束 |
| 比较| 00,01010| 0010,0<font color="#dd0000">1</font> | <font color="#dd0000">1</font>010 |部分积仅右移一位 |
| 加上0| 00,00000|  |   |
| 结果| 00,10100|  |   |
| |  |  |  |相加操作结束 |
| 右移| 00,00101| 00010,0 |  |移位作用于整个积(高位积和低位积)  |
| |  |  |  |右移一位操作结束 |
| 比较| 00,00101| 00010,<font color="#dd0000">0</font> | <font color="#dd0000">1</font>1010 |部分积加上[X]<sub>补</sub>,之后右移一位 |
| 加上[X]<sub>补</sub>| 11,00101|  |   |
| 结果| 11,01010|  |   |
| |  |  |  |相加操作结束 |
| 右移| 11,10101| 00001<font color="#dd0000">0</font>, | <font color="#dd0000">0</font>11010 |部分积仅右移一位 |
| 得出结果| <u>11,10101</u>| <u>00001</u><font color="#dd0000">0</font>, | <font color="#dd0000">0</font>11010 |下划线部分为计算结果的二进制补码 |







### 原码一位除法

计算规则
- 数值位取绝对值计算，最终结果的符号通过取两数符号进行异或运算决定
- 先用被除数减去除数，当余数为正时商上1，余数和商左移一位再减去除数；当余数为负，商上0，余数和商左移一位，再加上除数
    - 当第n+1次相加/减后的余数为负时，需加上$\vert Y \vert  $得到第n+1步正确的余数
        - 最后操作使余数与被除数同号


例：X=0.1011, Y=0.1101, 数值位4位，符号位1位。计算X/Y 


$\vert X \vert $=0.1011, $\vert Y \vert $=0.1101, 

 ($\vert X \vert $)<sub>补</sub>=0.1101, ( - $\vert Y \vert $)<sub>补</sub>=1.0011

![](https://github.com/fuqi0714/DailyWork/blob/main/CO/res/YD.png)

X、Y的符号进行异或运算：0 $\bigoplus$ 0=0， X/Y=+0.1101, 余数为0.0111*2<sup>-4</sup>

### 补码一位除法

计算规则
- 符号位与数值位共同参与运算，被除数取双符号位，除数取单符号位
- 先判断除数与被除数同号，用被除数减去除数；若异号，被除数加上除数
- 根据上一步计算结果，若被除数与除数同号，商上1，之后余数左移一位减去除数；异号则商上0，余数左移一位加上除数
    - 重复执行n次

例：X=0.1000, Y=-0.1011, 数值位4位，符号位1位。用补码除法计算X / Y

符号位两位，[X]<sub>原</sub>=00.1000, [X]<sub>补</sub>=00.1000,  [Y]<sub>原</sub>=11.1011, [Y]<sub>补</sub>=11.0101, [-Y]<sub>补</sub>=00.0101

![](https://github.com/fuqi0714/DailyWork/blob/main/CO/res/BD.png)

[X/Y]<sub>补</sub>=1.0101, 余数为0.0111*2<sup>-4</sup>


### 逻辑运算
| 操作数1 | 操作数2 | 与 | 或 | 异或 |
| :-----| :----: | :----: |:----: |:----: |
| 0| 1| 0 | 0 | 1 |
| 1| 0| 0| 1 | 1 |
| 0| 0| 0| 0 | 0 |
| 1| 1| 1| 1 | 0 |


# 存储器
## 随机存储器
### SRAM&DRAM

| 类型| SRAM | DRAM | 
| :-----: | :-----: | :----: | 
| 存储信息| 组合式触发器 | 单个电容固件 | 
| 破坏性读出| 否 | 是 | 
| 读出数据后是否需要重新生成信息| 否 | 是 | 
| 运行速度| 快 | 慢 | 
| 制作工艺| 低 | 高 | 
| 存储成本| 高 | 低 | 
| 是否易失| 是 | 是 | 
